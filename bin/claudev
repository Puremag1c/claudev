#!/bin/bash
# claudev CLI — управление многоагентной системой разработки
#
# Использование:
#   claudev init      Инициализация проекта + запуск orchestrator
#   claudev start     Запуск orchestrator (если уже инициализирован)
#   claudev status    Статус проекта
#   claudev update    Обновление claudev

set -euo pipefail

CLAUDEV_HOME="${CLAUDEV_HOME:-$HOME/.claudev}"
VERSION=$(cat "$CLAUDEV_HOME/VERSION" 2>/dev/null || echo "dev")

# === Colors ===

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

info()    { echo -e "${BLUE}▸${NC} $1"; }
success() { echo -e "${GREEN}✓${NC} $1"; }
warn()    { echo -e "${YELLOW}!${NC} $1"; }
error()   { echo -e "${RED}✗${NC} $1" >&2; }

# === Dependency check ===

check_deps() {
    local missing=()

    command -v bd &>/dev/null || missing+=("beads (bd)")
    command -v claude &>/dev/null || missing+=("claude-code")
    command -v gh &>/dev/null || missing+=("gh")
    command -v jq &>/dev/null || missing+=("jq")

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing dependencies: ${missing[*]}"
        echo ""
        echo "Install with:"
        echo "  curl -fsSL https://raw.githubusercontent.com/Puremag1c/claudev/main/install.sh | bash"
        exit 1
    fi
}

# === GitHub Setup ===

setup_github() {
    # Check if gh is authenticated
    if ! gh auth status &>/dev/null; then
        echo ""
        echo "GitHub позволяет хранить код в облаке и синхронизировать между устройствами."
        echo ""
        read -p "У вас есть аккаунт GitHub? (y/n) " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            info "Запускаем авторизацию GitHub..."
            echo ""
            if gh auth login; then
                success "GitHub авторизация успешна"
            else
                warn "Авторизация не удалась, работаем локально"
                return
            fi
        else
            info "Работаем локально (без GitHub)"
            return
        fi
    fi

    # Check if remote exists
    if ! git remote get-url origin &>/dev/null; then
        echo ""
        read -p "Создать GitHub репозиторий для этого проекта? (y/n) " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            local repo_name=$(basename "$(pwd)")
            info "Создаём приватный репозиторий $repo_name..."

            if gh repo create "$repo_name" --private --source=. --remote=origin; then
                success "GitHub репозиторий создан"
            else
                warn "Не удалось создать репозиторий, работаем локально"
            fi
        else
            info "Работаем локально (без GitHub)"
        fi
    else
        success "GitHub remote настроен"
    fi
}

# === Gitleaks Auto-Setup ===

setup_gitleaks() {
    # Skip if no GitHub remote (local projects don't need this)
    if ! git remote get-url origin &>/dev/null; then
        return
    fi

    # Try to install gitleaks if not present
    if ! command -v gitleaks &>/dev/null; then
        # Try brew (macOS/Linux with Homebrew)
        if command -v brew &>/dev/null; then
            brew install gitleaks &>/dev/null && success "gitleaks installed"
        # Try apt (Debian/Ubuntu)
        elif command -v apt &>/dev/null; then
            sudo apt install -y gitleaks &>/dev/null 2>&1 && success "gitleaks installed"
        fi
        # If neither works, silently skip
    fi

    # Setup pre-commit hook if gitleaks is available
    if command -v gitleaks &>/dev/null; then
        local hook_file=".git/hooks/pre-commit"

        # Create hooks dir if needed
        mkdir -p .git/hooks

        # Add gitleaks to pre-commit (or create new hook)
        if [[ -f "$hook_file" ]]; then
            if ! grep -q "gitleaks" "$hook_file"; then
                # Append to existing hook
                echo "" >> "$hook_file"
                echo "# Gitleaks - prevent secret leaks" >> "$hook_file"
                echo "gitleaks protect --staged --verbose" >> "$hook_file"
                success "gitleaks hook added"
            fi
        else
            # Create new hook
            cat > "$hook_file" << 'HOOK'
#!/bin/bash
# Gitleaks - prevent secret leaks
gitleaks protect --staged --verbose
HOOK
            chmod +x "$hook_file"
            success "gitleaks hook created"
        fi
    fi
}

# === MCP Servers Setup ===

setup_mcp() {
    # Skip if .mcp.json already exists
    if [[ -f ".mcp.json" ]]; then
        success "MCP servers configured (.mcp.json exists)"
        return
    fi

    info "Configuring MCP servers..."

    # Start with empty mcpServers object
    local mcp_config='{"mcpServers":{}}'

    # 1. Playwright - always add (no auth required)
    mcp_config=$(echo "$mcp_config" | jq '.mcpServers.playwright = {
        "command": "npx",
        "args": ["-y", "@playwright/mcp@latest"]
    }')
    success "Added Playwright MCP (browser automation)"

    # 2. GitHub - add if gh is authenticated
    if gh auth status &>/dev/null; then
        # Use gh auth token dynamically via command substitution
        # Token is NOT stored in file - fetched at runtime
        mcp_config=$(echo "$mcp_config" | jq '.mcpServers.github = {
            "command": "sh",
            "args": ["-c", "GITHUB_PERSONAL_ACCESS_TOKEN=$(gh auth token) npx -y @modelcontextprotocol/server-github"]
        }')
        success "Added GitHub MCP (repo management)"
    else
        info "GitHub MCP skipped (gh not authenticated)"
    fi

    # 3. PostgreSQL - add template with placeholder
    mcp_config=$(echo "$mcp_config" | jq '.mcpServers["postgres"] = {
        "command": "npx",
        "args": ["-y", "@bytebase/dbhub", "--dsn", "env:DATABASE_URL"],
        "env": {
            "DATABASE_URL": "postgresql://user:password@localhost:5432/mydb"
        }
    }')

    # 4. Supabase - add template with placeholder
    mcp_config=$(echo "$mcp_config" | jq '.mcpServers["supabase"] = {
        "command": "npx",
        "args": ["-y", "@supabase/mcp-server-supabase@latest", "--access-token", "env:SUPABASE_ACCESS_TOKEN"],
        "env": {
            "SUPABASE_ACCESS_TOKEN": "your-supabase-access-token"
        }
    }')

    # Write .mcp.json
    echo "$mcp_config" | jq '.' > .mcp.json

    success "Created .mcp.json"
    echo ""
    info "MCP servers configured:"
    echo "  - playwright: Ready to use"
    if gh auth status &>/dev/null; then
        echo "  - github: Ready to use"
    fi
    echo "  - postgres: Edit DATABASE_URL in .mcp.json"
    echo "  - supabase: Edit SUPABASE_ACCESS_TOKEN in .mcp.json"
}

# === Project Type Detection ===

detect_project_type() {
    # Check for existing SPEC.md
    if [[ -f "SPEC.md" ]]; then
        echo "has_spec"
        return
    fi

    # Check for code files
    local has_code=false

    # Common code file patterns
    for pattern in "*.ts" "*.tsx" "*.js" "*.jsx" "*.py" "*.ex" "*.exs" "*.go" "*.rs" "*.java" "*.rb"; do
        if compgen -G "$pattern" > /dev/null 2>&1 || compgen -G "src/$pattern" > /dev/null 2>&1; then
            has_code=true
            break
        fi
    done

    # Check for project manifest files (indicates existing project)
    if [[ -f "package.json" ]] || [[ -f "mix.exs" ]] || [[ -f "go.mod" ]] || \
       [[ -f "Cargo.toml" ]] || [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]]; then
        has_code=true
    fi

    if [[ "$has_code" = true ]]; then
        echo "existing"
    else
        echo "empty"
    fi
}

# === Init ===

cmd_init() {
    info "Initializing claudev in $(pwd)"

    check_deps

    # Beads daemon (auto-start if not running)
    if ! bd daemon status &>/dev/null; then
        info "Starting beads daemon..."
        bd daemon start &>/dev/null
        success "beads daemon started"
    else
        success "beads daemon running"
    fi

    # Detect project type BEFORE init
    local project_type=$(detect_project_type)

    # Git
    if [[ ! -d ".git" ]]; then
        info "Initializing git..."
        git init -q
        success "git init"
    else
        success "git already initialized"
    fi

    # GitHub setup (interactive)
    setup_github

    # Gitleaks auto-setup (only if GitHub configured)
    setup_gitleaks

    # MCP servers setup
    setup_mcp

    # Beads
    if [[ ! -d ".beads" ]]; then
        info "Initializing beads..."
        bd init
        success "bd init"
    else
        success "beads already initialized"
    fi

    # .claudev/config.sh
    mkdir -p .claudev

    # Save claudev version for upgrade detection
    echo "$VERSION" > .claudev/version
    success "Saved claudev version ($VERSION)"

    if [[ ! -f ".claudev/config.sh" ]]; then
        info "Creating config..."
        cp "$CLAUDEV_HOME/templates/config.template.sh" .claudev/config.sh
        success "Created .claudev/config.sh"
    else
        success ".claudev/config.sh exists"
    fi

    # Symlinks
    mkdir -p .claude

    # Link .claude/agents (handle existing directory)
    if [[ -L ".claude/agents" ]]; then
        success ".claude/agents already linked"
    elif [[ -d ".claude/agents" ]]; then
        warn ".claude/agents is a directory, renaming to .claude/agents.backup"
        mv .claude/agents .claude/agents.backup
        ln -sf "$CLAUDEV_HOME/core/agents" .claude/agents
        success "Linked .claude/agents (old dir backed up)"
    else
        ln -sf "$CLAUDEV_HOME/core/agents" .claude/agents
        success "Linked .claude/agents"
    fi

    # Link .claude/commands (handle existing directory)
    if [[ -L ".claude/commands" ]]; then
        success ".claude/commands already linked"
    elif [[ -d ".claude/commands" ]]; then
        warn ".claude/commands is a directory, renaming to .claude/commands.backup"
        mv .claude/commands .claude/commands.backup
        ln -sf "$CLAUDEV_HOME/core/commands" .claude/commands
        success "Linked .claude/commands (old dir backed up)"
    else
        ln -sf "$CLAUDEV_HOME/core/commands" .claude/commands
        success "Linked .claude/commands"
    fi

    # Link scripts/ (handle existing directory - common in projects)
    if [[ -L "scripts" ]]; then
        success "scripts/ already linked"
    elif [[ -d "scripts" ]]; then
        warn "scripts/ directory exists, renaming to project-scripts/"
        mv scripts project-scripts
        ln -sf "$CLAUDEV_HOME/core/scripts" scripts
        success "Linked scripts/ (old dir renamed to project-scripts/)"
        info "Your original scripts are in project-scripts/"
    else
        ln -sf "$CLAUDEV_HOME/core/scripts" scripts
        success "Linked scripts/"
    fi

    # .claude/settings.json
    if [[ ! -f ".claude/settings.json" ]]; then
        info "Creating Claude Code settings..."
        cat > .claude/settings.json << 'EOF'
{
  "permissions": {
    "allow": [
      "Bash(bd *)",
      "Bash(git *)",
      "Bash(gh *)",
      "Bash(./scripts/*)"
    ],
    "deny": []
  }
}
EOF
        success "Created .claude/settings.json"
    else
        success ".claude/settings.json exists"
    fi

    # .gitignore
    if [[ -f ".gitignore" ]]; then
        if ! grep -q "# Claudev" .gitignore 2>/dev/null; then
            info "Updating .gitignore..."
            cat >> .gitignore << 'EOF'

# Claudev
.claudev/
.claude/agents
.claude/commands
scripts
project-scripts/
logs/
stats/
PROJECT_CONTEXT.md
SPEC.md
SPEC.draft.md
.mcp.json
EOF
            success "Updated .gitignore"
        fi
    else
        info "Creating .gitignore..."
        cat > .gitignore << 'EOF'
# Claudev
.claudev/
.claude/agents
.claude/commands
scripts
project-scripts/
logs/
stats/
PROJECT_CONTEXT.md
SPEC.md
SPEC.draft.md
.mcp.json
EOF
        success "Created .gitignore"
    fi

    # Handle project type
    echo ""
    case "$project_type" in
        has_spec)
            success "Found SPEC.md - will skip to PLANNING phase"
            ;;
        existing)
            info "Detected existing project, analyzing..."
            "$CLAUDEV_HOME/core/scripts/analyze-project.sh"
            success "Created PROJECT_CONTEXT.md"
            ;;
        empty)
            info "Empty project - Tech Writer will gather requirements"
            ;;
    esac

    # Save project type for orchestrator
    echo "$project_type" > .claudev/project_type

    # Auto-commit .gitignore if changed
    if git diff --quiet .gitignore 2>/dev/null || git ls-files --others --exclude-standard | grep -q "^\.gitignore$"; then
        git add .gitignore
        git commit -m "chore: Add claudev entries to .gitignore" --no-verify -q 2>/dev/null && \
            success "Committed .gitignore"
    fi

    echo ""
    success "Project initialized!"
    echo ""
    info "Starting orchestrator..."
    echo ""

    exec "$CLAUDEV_HOME/core/scripts/orchestrator.sh"
}

# === Start ===

cmd_start() {
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project. Run 'claudev init' first."
        exit 1
    fi

    check_deps

    # Beads daemon (auto-start if not running)
    if ! bd daemon status &>/dev/null; then
        info "Starting beads daemon..."
        bd daemon start &>/dev/null
        success "beads daemon started"
    fi

    info "Starting orchestrator..."
    exec "$CLAUDEV_HOME/core/scripts/orchestrator.sh"
}

# === Status ===

cmd_status() {
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project."
        exit 1
    fi

    echo "claudev $VERSION"
    echo ""

    # Orchestrator status
    local lock_file=".claudev/orchestrator.lock"
    if [[ -f "$lock_file" ]]; then
        local pid=$(cat "$lock_file" 2>/dev/null || echo "0")
        if kill -0 "$pid" 2>/dev/null; then
            success "Orchestrator running (PID $pid)"
        else
            warn "Stale lock file (PID $pid not found)"
        fi
    else
        info "Orchestrator not running"
    fi

    echo ""

    # Beads stats
    if command -v bd &>/dev/null && [[ -d ".beads" ]]; then
        bd stats 2>/dev/null || true
    fi
}

# === Update ===

cmd_update() {
    info "Updating claudev..."

    if [[ -d "$CLAUDEV_HOME/.git" ]]; then
        cd "$CLAUDEV_HOME"
        git fetch origin
        # Handle force-pushed commits (diverged history)
        if ! git pull --ff-only 2>/dev/null; then
            warn "History diverged, resetting to origin/main..."
            git reset --hard origin/main
        fi
        success "Updated to $(cat VERSION)"
    else
        warn "Not a git installation, re-run install.sh"
    fi
}

# === Upgrade ===

cmd_upgrade() {
    local upgrade_all=false
    local force=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all) upgrade_all=true; shift ;;
            --force|-f) force=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ "$upgrade_all" = true ]]; then
        upgrade_all_projects "$force"
        return
    fi

    # Single project upgrade
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project. Run 'claudev init' first."
        exit 1
    fi

    upgrade_project "$(pwd)" "$force"
}

upgrade_project() {
    local project_dir="$1"
    local force="${2:-false}"

    cd "$project_dir"

    local project_version=$(cat .claudev/version 2>/dev/null || echo "unknown")

    if [[ "$project_version" = "$VERSION" ]] && [[ "$force" != "true" ]]; then
        success "Project already at version $VERSION"
        return
    fi

    info "Upgrading $(basename "$project_dir"): $project_version → $VERSION"

    # Run migrations if available
    run_migrations "$project_version" "$VERSION"

    # Update symlinks
    if [[ -L ".claude/agents" ]]; then
        rm -f .claude/agents
        ln -sf "$CLAUDEV_HOME/core/agents" .claude/agents
        success "Updated .claude/agents symlink"
    fi

    if [[ -L ".claude/commands" ]]; then
        rm -f .claude/commands
        ln -sf "$CLAUDEV_HOME/core/commands" .claude/commands
        success "Updated .claude/commands symlink"
    fi

    if [[ -L "scripts" ]]; then
        rm -f scripts
        ln -sf "$CLAUDEV_HOME/core/scripts" scripts
        success "Updated scripts/ symlink"
    fi

    # Update config.sh (merge strategy: keep user customizations)
    if [[ -f ".claudev/config.sh" ]]; then
        local template="$CLAUDEV_HOME/templates/config.template.sh"
        if [[ -f "$template" ]]; then
            # Check if user has customized the file
            if diff -q "$template" ".claudev/config.sh" &>/dev/null; then
                # Not customized, safe to replace
                cp "$template" ".claudev/config.sh"
                success "Updated .claudev/config.sh"
            else
                # User has customizations, keep them but warn
                warn ".claudev/config.sh has customizations, keeping current version"
                info "Template at: $template"
            fi
        fi
    fi

    # Update .gitignore entries
    update_gitignore

    # Update version marker
    echo "$VERSION" > .claudev/version

    success "Upgraded to $VERSION"
}

update_gitignore() {
    if [[ ! -f ".gitignore" ]]; then
        return
    fi

    local entries=(".claudev/" ".claude/agents" ".claude/commands" "scripts" "project-scripts/" "logs/" "stats/" "PROJECT_CONTEXT.md" "SPEC.md" "SPEC.draft.md" ".mcp.json")
    local added=()

    for entry in "${entries[@]}"; do
        if ! grep -qF "$entry" .gitignore 2>/dev/null; then
            echo "$entry" >> .gitignore
            added+=("$entry")
        fi
    done

    if [[ ${#added[@]} -gt 0 ]]; then
        success "Added to .gitignore: ${added[*]}"
    fi
}

run_migrations() {
    local from_version="$1"
    local to_version="$2"

    local migrations_dir="$CLAUDEV_HOME/migrations"
    if [[ ! -d "$migrations_dir" ]]; then
        return
    fi

    # Find and run applicable migrations
    for migration in "$migrations_dir"/*.sh; do
        if [[ ! -f "$migration" ]]; then
            continue
        fi

        local migration_name=$(basename "$migration" .sh)
        # Migration names like: 0.8.0-to-0.9.0.sh
        if [[ "$migration_name" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-to-([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            local migration_from="${BASH_REMATCH[1]}"
            local migration_to="${BASH_REMATCH[2]}"

            # Check if migration applies
            if version_gte "$from_version" "$migration_from" && version_lt "$from_version" "$migration_to"; then
                info "Running migration: $migration_name"
                source "$migration"
            fi
        fi
    done
}

# Version comparison helpers
version_gte() {
    [[ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$2" ]]
}

version_lt() {
    [[ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$1" ]] && [[ "$1" != "$2" ]]
}

upgrade_all_projects() {
    local force="${1:-false}"

    info "Discovering claudev projects..."

    local projects=()
    local search_dirs=("$HOME/Projects" "$HOME/Code" "$HOME/Dev" "$HOME/Zen/Code" "$HOME/work")

    for dir in "${search_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            while IFS= read -r -d '' project; do
                projects+=("$(dirname "$project")")
            done < <(find "$dir" -maxdepth 3 -type d -name ".claudev" -print0 2>/dev/null)
        fi
    done

    if [[ ${#projects[@]} -eq 0 ]]; then
        warn "No claudev projects found"
        info "Searched in: ${search_dirs[*]}"
        return
    fi

    success "Found ${#projects[@]} project(s)"
    echo ""

    for project in "${projects[@]}"; do
        echo "━━━ $(basename "$project") ━━━"
        upgrade_project "$project" "$force"
        echo ""
    done

    success "All projects upgraded"
}

# === Delete ===

cmd_delete() {
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project."
        exit 1
    fi

    echo "This will remove claudev from the current project."
    echo ""
    echo "Will delete:"
    echo "  - .claudev/          (config, lock files)"
    echo "  - .claude/agents     (symlink)"
    echo "  - .claude/commands   (symlink)"
    echo "  - .claude/settings.json"
    echo "  - scripts/           (symlink)"
    echo "  - logs/"
    echo "  - stats/"
    echo ""
    echo "Will NOT touch:"
    echo "  - .beads/            (your project data)"
    echo "  - .git/"
    echo "  - SPEC.md"
    echo "  - Your code"
    echo ""

    read -p "Continue? (y/N) " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Cancelled."
        exit 0
    fi

    # Stop orchestrator if running
    local lock_file=".claudev/orchestrator.lock"
    if [[ -f "$lock_file" ]]; then
        local pid=$(cat "$lock_file" 2>/dev/null || echo "0")
        if kill -0 "$pid" 2>/dev/null; then
            info "Stopping orchestrator (PID $pid)..."
            kill "$pid" 2>/dev/null || true
            sleep 1
        fi
    fi

    # Remove claudev files
    local deleted=()

    if [[ -d ".claudev" ]]; then
        rm -rf .claudev
        deleted+=(".claudev/")
    fi

    if [[ -L ".claude/agents" ]]; then
        rm -f .claude/agents
        deleted+=(".claude/agents")
    fi

    if [[ -L ".claude/commands" ]]; then
        rm -f .claude/commands
        deleted+=(".claude/commands")
    fi

    if [[ -f ".claude/settings.json" ]]; then
        rm -f .claude/settings.json
        deleted+=(".claude/settings.json")
    fi

    # Remove .claude if empty
    if [[ -d ".claude" ]] && [[ -z "$(ls -A .claude 2>/dev/null)" ]]; then
        rmdir .claude
        deleted+=(".claude/")
    fi

    if [[ -L "scripts" ]]; then
        rm -f scripts
        deleted+=("scripts/")
    fi

    if [[ -d "logs" ]]; then
        rm -rf logs
        deleted+=("logs/")
    fi

    if [[ -d "stats" ]]; then
        rm -rf stats
        deleted+=("stats/")
    fi

    # Clean up PROJECT_CONTEXT.md if exists
    if [[ -f "PROJECT_CONTEXT.md" ]]; then
        rm -f PROJECT_CONTEXT.md
        deleted+=("PROJECT_CONTEXT.md")
    fi

    echo ""
    success "Claudev removed from project"
    echo ""
    echo "Deleted:"
    for item in "${deleted[@]}"; do
        echo "  - $item"
    done
}

# === Help ===

cmd_help() {
    echo "claudev $VERSION — multi-agent development system"
    echo ""
    echo "Usage: claudev <command>"
    echo ""
    echo "Commands:"
    echo "  init      Initialize project and start orchestrator"
    echo "  start     Start orchestrator (project must be initialized)"
    echo "  status    Show project and orchestrator status"
    echo "  update    Update claudev to latest version"
    echo "  upgrade   Upgrade current project to latest claudev version"
    echo "            --all    Upgrade all discovered projects"
    echo "            --force  Force upgrade even if versions match"
    echo "  delete    Remove claudev from project (keeps .beads, code)"
    echo ""
    echo "Home: $CLAUDEV_HOME"
}

# === Main ===

case "${1:-}" in
    init)   cmd_init ;;
    start)  cmd_start ;;
    status) cmd_status ;;
    update) cmd_update ;;
    upgrade) shift; cmd_upgrade "$@" ;;
    delete) cmd_delete ;;
    -h|--help|help|"") cmd_help ;;
    *)
        error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
