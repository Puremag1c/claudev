#!/bin/bash
# claudev CLI — управление многоагентной системой разработки
#
# Использование:
#   claudev init      Инициализация проекта + запуск orchestrator
#   claudev start     Запуск orchestrator (если уже инициализирован)
#   claudev status    Статус проекта
#   claudev update    Обновление claudev

set -euo pipefail

CLAUDEV_HOME="${CLAUDEV_HOME:-$HOME/.claudev}"
VERSION=$(cat "$CLAUDEV_HOME/VERSION" 2>/dev/null || echo "dev")

# === Colors ===

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

info()    { echo -e "${BLUE}▸${NC} $1"; }
success() { echo -e "${GREEN}✓${NC} $1"; }
warn()    { echo -e "${YELLOW}!${NC} $1"; }
error()   { echo -e "${RED}✗${NC} $1" >&2; }

# === Dependency check ===

check_deps() {
    local missing=()

    command -v bd &>/dev/null || missing+=("beads (bd)")
    command -v claude &>/dev/null || missing+=("claude-code")
    command -v gh &>/dev/null || missing+=("gh")
    command -v jq &>/dev/null || missing+=("jq")

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing dependencies: ${missing[*]}"
        echo ""
        echo "Install with:"
        echo "  curl -fsSL https://raw.githubusercontent.com/Puremag1c/claudev/main/install.sh | bash"
        exit 1
    fi
}

# === GitHub Setup ===

setup_github() {
    # Check if gh is authenticated
    if ! gh auth status &>/dev/null; then
        echo ""
        echo "GitHub позволяет хранить код в облаке и синхронизировать между устройствами."
        echo ""
        read -p "У вас есть аккаунт GitHub? (y/n) " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            info "Запускаем авторизацию GitHub..."
            echo ""
            if gh auth login; then
                success "GitHub авторизация успешна"
            else
                warn "Авторизация не удалась, работаем локально"
                return
            fi
        else
            info "Работаем локально (без GitHub)"
            return
        fi
    fi

    # Check if remote exists
    if ! git remote get-url origin &>/dev/null; then
        echo ""
        read -p "Создать GitHub репозиторий для этого проекта? (y/n) " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            local repo_name=$(basename "$(pwd)")
            info "Создаём приватный репозиторий $repo_name..."

            if gh repo create "$repo_name" --private --source=. --remote=origin; then
                success "GitHub репозиторий создан"
            else
                warn "Не удалось создать репозиторий, работаем локально"
            fi
        else
            info "Работаем локально (без GitHub)"
        fi
    else
        success "GitHub remote настроен"
    fi
}

# === Gitleaks Auto-Setup ===

setup_gitleaks() {
    # Skip if no GitHub remote (local projects don't need this)
    if ! git remote get-url origin &>/dev/null; then
        return
    fi

    # Try to install gitleaks if not present
    if ! command -v gitleaks &>/dev/null; then
        # Try brew (macOS/Linux with Homebrew)
        if command -v brew &>/dev/null; then
            brew install gitleaks &>/dev/null && success "gitleaks installed"
        # Try apt (Debian/Ubuntu)
        elif command -v apt &>/dev/null; then
            sudo apt install -y gitleaks &>/dev/null 2>&1 && success "gitleaks installed"
        fi
        # If neither works, silently skip
    fi

    # Setup pre-commit hook if gitleaks is available
    if command -v gitleaks &>/dev/null; then
        local hook_file=".git/hooks/pre-commit"

        # Create hooks dir if needed
        mkdir -p .git/hooks

        # Add gitleaks to pre-commit (or create new hook)
        if [[ -f "$hook_file" ]]; then
            if ! grep -q "gitleaks" "$hook_file"; then
                # Append to existing hook
                echo "" >> "$hook_file"
                echo "# Gitleaks - prevent secret leaks" >> "$hook_file"
                echo "gitleaks protect --staged --verbose" >> "$hook_file"
                success "gitleaks hook added"
            fi
        else
            # Create new hook
            cat > "$hook_file" << 'HOOK'
#!/bin/bash
# Gitleaks - prevent secret leaks
gitleaks protect --staged --verbose
HOOK
            chmod +x "$hook_file"
            success "gitleaks hook created"
        fi
    fi
}

# === Project Type Detection ===

detect_project_type() {
    # Check for existing SPEC.md
    if [[ -f "SPEC.md" ]]; then
        echo "has_spec"
        return
    fi

    # Check for code files
    local has_code=false

    # Common code file patterns
    for pattern in "*.ts" "*.tsx" "*.js" "*.jsx" "*.py" "*.ex" "*.exs" "*.go" "*.rs" "*.java" "*.rb"; do
        if compgen -G "$pattern" > /dev/null 2>&1 || compgen -G "src/$pattern" > /dev/null 2>&1; then
            has_code=true
            break
        fi
    done

    # Check for project manifest files (indicates existing project)
    if [[ -f "package.json" ]] || [[ -f "mix.exs" ]] || [[ -f "go.mod" ]] || \
       [[ -f "Cargo.toml" ]] || [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]]; then
        has_code=true
    fi

    if [[ "$has_code" = true ]]; then
        echo "existing"
    else
        echo "empty"
    fi
}

# === Init ===

cmd_init() {
    info "Initializing claudev in $(pwd)"

    check_deps

    # Beads daemon (auto-start if not running)
    if ! bd daemon status &>/dev/null; then
        info "Starting beads daemon..."
        bd daemon start &>/dev/null
        success "beads daemon started"
    else
        success "beads daemon running"
    fi

    # Detect project type BEFORE init
    local project_type=$(detect_project_type)

    # Git
    if [[ ! -d ".git" ]]; then
        info "Initializing git..."
        git init -q
        success "git init"
    else
        success "git already initialized"
    fi

    # GitHub setup (interactive)
    setup_github

    # Gitleaks auto-setup (only if GitHub configured)
    setup_gitleaks

    # Beads
    if [[ ! -d ".beads" ]]; then
        info "Initializing beads..."
        bd init
        success "bd init"
    else
        success "beads already initialized"
    fi

    # .claudev/config.sh
    mkdir -p .claudev
    if [[ ! -f ".claudev/config.sh" ]]; then
        info "Creating config..."
        cp "$CLAUDEV_HOME/templates/config.template.sh" .claudev/config.sh
        success "Created .claudev/config.sh"
    else
        success ".claudev/config.sh exists"
    fi

    # Symlinks
    mkdir -p .claude

    if [[ ! -L ".claude/agents" ]]; then
        ln -sf "$CLAUDEV_HOME/core/agents" .claude/agents
        success "Linked .claude/agents"
    fi

    if [[ ! -L ".claude/commands" ]]; then
        ln -sf "$CLAUDEV_HOME/core/commands" .claude/commands
        success "Linked .claude/commands"
    fi

    if [[ ! -L "scripts" ]]; then
        ln -sf "$CLAUDEV_HOME/core/scripts" scripts
        success "Linked scripts/"
    fi

    # .claude/settings.json
    if [[ ! -f ".claude/settings.json" ]]; then
        info "Creating Claude Code settings..."
        cat > .claude/settings.json << 'EOF'
{
  "permissions": {
    "allow": [
      "Bash(bd *)",
      "Bash(git *)",
      "Bash(gh *)",
      "Bash(./scripts/*)"
    ],
    "deny": []
  }
}
EOF
        success "Created .claude/settings.json"
    else
        success ".claude/settings.json exists"
    fi

    # .gitignore
    if [[ -f ".gitignore" ]]; then
        if ! grep -q "logs/" .gitignore 2>/dev/null; then
            info "Updating .gitignore..."
            cat >> .gitignore << 'EOF'

# Claudev
logs/
stats/
.claudev/*.lock
PROJECT_CONTEXT.md
EOF
            success "Updated .gitignore"
        fi
    else
        info "Creating .gitignore..."
        cat > .gitignore << 'EOF'
# Claudev
logs/
stats/
.claudev/*.lock
PROJECT_CONTEXT.md
EOF
        success "Created .gitignore"
    fi

    # Handle project type
    echo ""
    case "$project_type" in
        has_spec)
            success "Found SPEC.md - will skip to PLANNING phase"
            ;;
        existing)
            info "Detected existing project, analyzing..."
            "$CLAUDEV_HOME/core/scripts/analyze-project.sh"
            success "Created PROJECT_CONTEXT.md"
            ;;
        empty)
            info "Empty project - Tech Writer will gather requirements"
            ;;
    esac

    # Save project type for orchestrator
    echo "$project_type" > .claudev/project_type

    echo ""
    success "Project initialized!"
    echo ""
    info "Starting orchestrator..."
    echo ""

    exec "$CLAUDEV_HOME/core/scripts/orchestrator.sh"
}

# === Start ===

cmd_start() {
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project. Run 'claudev init' first."
        exit 1
    fi

    check_deps

    # Beads daemon (auto-start if not running)
    if ! bd daemon status &>/dev/null; then
        info "Starting beads daemon..."
        bd daemon start &>/dev/null
        success "beads daemon started"
    fi

    info "Starting orchestrator..."
    exec "$CLAUDEV_HOME/core/scripts/orchestrator.sh"
}

# === Status ===

cmd_status() {
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project."
        exit 1
    fi

    echo "claudev $VERSION"
    echo ""

    # Orchestrator status
    local lock_file=".claudev/orchestrator.lock"
    if [[ -f "$lock_file" ]]; then
        local pid=$(cat "$lock_file" 2>/dev/null || echo "0")
        if kill -0 "$pid" 2>/dev/null; then
            success "Orchestrator running (PID $pid)"
        else
            warn "Stale lock file (PID $pid not found)"
        fi
    else
        info "Orchestrator not running"
    fi

    echo ""

    # Beads stats
    if command -v bd &>/dev/null && [[ -d ".beads" ]]; then
        bd stats 2>/dev/null || true
    fi
}

# === Update ===

cmd_update() {
    info "Updating claudev..."

    if [[ -d "$CLAUDEV_HOME/.git" ]]; then
        cd "$CLAUDEV_HOME"
        git pull --ff-only
        success "Updated to $(cat VERSION)"
    else
        warn "Not a git installation, re-run install.sh"
    fi
}

# === Delete ===

cmd_delete() {
    if [[ ! -d ".claudev" ]]; then
        error "Not a claudev project."
        exit 1
    fi

    echo "This will remove claudev from the current project."
    echo ""
    echo "Will delete:"
    echo "  - .claudev/          (config, lock files)"
    echo "  - .claude/agents     (symlink)"
    echo "  - .claude/commands   (symlink)"
    echo "  - .claude/settings.json"
    echo "  - scripts/           (symlink)"
    echo "  - logs/"
    echo "  - stats/"
    echo ""
    echo "Will NOT touch:"
    echo "  - .beads/            (your project data)"
    echo "  - .git/"
    echo "  - SPEC.md"
    echo "  - Your code"
    echo ""

    read -p "Continue? (y/N) " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Cancelled."
        exit 0
    fi

    # Stop orchestrator if running
    local lock_file=".claudev/orchestrator.lock"
    if [[ -f "$lock_file" ]]; then
        local pid=$(cat "$lock_file" 2>/dev/null || echo "0")
        if kill -0 "$pid" 2>/dev/null; then
            info "Stopping orchestrator (PID $pid)..."
            kill "$pid" 2>/dev/null || true
            sleep 1
        fi
    fi

    # Remove claudev files
    local deleted=()

    if [[ -d ".claudev" ]]; then
        rm -rf .claudev
        deleted+=(".claudev/")
    fi

    if [[ -L ".claude/agents" ]]; then
        rm -f .claude/agents
        deleted+=(".claude/agents")
    fi

    if [[ -L ".claude/commands" ]]; then
        rm -f .claude/commands
        deleted+=(".claude/commands")
    fi

    if [[ -f ".claude/settings.json" ]]; then
        rm -f .claude/settings.json
        deleted+=(".claude/settings.json")
    fi

    # Remove .claude if empty
    if [[ -d ".claude" ]] && [[ -z "$(ls -A .claude 2>/dev/null)" ]]; then
        rmdir .claude
        deleted+=(".claude/")
    fi

    if [[ -L "scripts" ]]; then
        rm -f scripts
        deleted+=("scripts/")
    fi

    if [[ -d "logs" ]]; then
        rm -rf logs
        deleted+=("logs/")
    fi

    if [[ -d "stats" ]]; then
        rm -rf stats
        deleted+=("stats/")
    fi

    # Clean up PROJECT_CONTEXT.md if exists
    if [[ -f "PROJECT_CONTEXT.md" ]]; then
        rm -f PROJECT_CONTEXT.md
        deleted+=("PROJECT_CONTEXT.md")
    fi

    echo ""
    success "Claudev removed from project"
    echo ""
    echo "Deleted:"
    for item in "${deleted[@]}"; do
        echo "  - $item"
    done
}

# === Help ===

cmd_help() {
    echo "claudev $VERSION — multi-agent development system"
    echo ""
    echo "Usage: claudev <command>"
    echo ""
    echo "Commands:"
    echo "  init      Initialize project and start orchestrator"
    echo "  start     Start orchestrator (project must be initialized)"
    echo "  status    Show project and orchestrator status"
    echo "  update    Update claudev to latest version"
    echo "  delete    Remove claudev from project (keeps .beads, code)"
    echo ""
    echo "Home: $CLAUDEV_HOME"
}

# === Main ===

case "${1:-}" in
    init)   cmd_init ;;
    start)  cmd_start ;;
    status) cmd_status ;;
    update) cmd_update ;;
    delete) cmd_delete ;;
    -h|--help|help|"") cmd_help ;;
    *)
        error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
